# Dagger-Basics
__Dagger 2:__ Dagger2 is a fully static, compile-time dependency injection framework for Java, Kotlin, and Android.
Dagger 2 uses the following annotations:
* @Module and @Provides: define classes and methods which provide dependencies
* @Inject: request dependencies. Can be used on a constructor, a field, or a method
* @Component: enable selected modules and used for performing dependency injection

__Type of annotations in DI__
* @Inject
* @Module
* @Component
* @Provides
* @Binds
* @Subcomponent
It’s a child component for a @Component. Everything in @Component can be accessed by its subcomponents. It needs to be under a @Component for it to work.

__Scope Annotations:__
* @Singleton
* @ActivityScope
* @Retention

__Q1. What is the use of @Module annotation?__
__Dependency provider:__
* Used on classes which contains methods annotated with @Provides or @Binds.
* The returned objects from these methods are available for dependency injection.

__Q2. What is @Provide annotations?__
 @Provide annotations Can be used on methods in classes annotated with @Module and is used for methods which provides objects for dependencies injection.


__Q3. What is the use of @Inject annotation?__
__Dependency consumer:__
The @Inject annotation is used to define a dependency for a object.

__Q4. What is Component in DI?__
__Connecting consumer and producer:__
* Used on an interface. This interface is used by Dagger 2 to generate code which uses the modules to fulfill the requested dependencies.
* Components are essentially the glue that holds everything together.
* They are a way of telling Dagger 2 what dependencies should be bundled together and made available to a given instance so they can be used.
* They provide a way for a class to request dependencies being injected through their @Inject annotation
* A @Component annotated interface defines the connection between the provider of objects (modules) and the objects which express/have a dependency. The class for this connection is generated by the Dagger.

__Q4. What is @Provide annotations?__
Single instance of this provided object is created and shared.

__Q5. What is the difference b/w @Provides and @Binds annotations?__

You cannot annotate interfaces with @Inject since interfaces don’t have constructors. However, if you have a one-to-one mapping between an interface and implementation, you can use @Binds or @Provides to make an interface injectable. Injecting an interface (rather than a concrete implementation) is always a good practice for several reasons including ease of testing. 

__@Provides Annotations:__
* In normal class moudule @Provides annotation works.
* and @Provides annotated methods require a concrete class as a method parameter in order to construct an instance on which the method can be invoked.
* but it introduces unnecessary boilerplate, generates more code such as Module Factory classes for all your dependencies which in turn increases the method count in your .apk or .aab.
* There can be more than one parameter method 

__Eg:__

```
@Module
class RepositoryModule {

    @Provides
    @Singleton
    fun providesUserRepository(api: Api): UserRepository {
        return UserRepositoryImpl(api)
    }
}
```

__@Binds Annotations:__
* In abstract class module only @Binds annotation works.
* @Binds method must be abstract and has no method body 
* There should only be one method parameter and parameter should be implementing class in order to construct an instance on which the method can be invoked.
* The parameter must be assignable to the return type
* The parameter must have an @Inject annotated constructor

__Eg:__

```
@Module
abstract class RepositoryModule {

    @Binds
    @Singleton
    abstract fun providesUserRepository(userRepository: UserRepositoryImpl): UserRepository
}

```

Extra module factory classes
Below are the classes generated.


Note that @Provides generates the MyModule_GetInjectClassFactory class, which doesn’t exist in @Binds






